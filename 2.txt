La vida es Corta
----------------

    Hasta que cumple veinticinco, todo hombre piensa cada tanto que dadas las
    circunstancias correctas podría ser el más jodido del mundo. Si me mudara
    a un monasterio de artes marciales en China y estudiara duro por diez años.
    Si mi familia fuera masacrada por traficantes colombianos y jurara venganza.
    Si tuviera una enfermedad fatal, me quedara un año de vida y lo dedicara a
    acabar con el crimen. Si tan sólo abandonara todo y dedicara mi vida a ser
    jodido.

    -- Neal Stephenson (Snow Crash)

A los veinticinco, sin embargo, uno se da cuenta que realmente no vale la pena
pasarse diez años estudiando en un monasterio, porque no hay WiFi y no hay una
cantidad ilimitada de años como para hacerse el Kung Fu.

De la misma forma, cuando uno empieza a programar cree que cada cosa que
encuentra podría rehacerse mejor. Ese framework web es demasiado grande y
complejo. Esa herramienta de blog no tiene exactamente los features que yo
quiero. Y la reacción es "¡Yo puedo hacerlo mejor!" y ponerse a programar
furiosamente para demostrarlo.

Eso es bueno y es malo.

Es bueno porque a veces de ahí salen cosas que son, efectivamente, mucho mejores
que las existentes. Si nadie hiciera esto, el software en general sería una
porquería.

Es malo porque la gran gran mayoria de las veces, tratando de implementar el
framework web número 9856, que es un 0.01% mejor que los existentes, se pasa
un año y no se hace algo original que realmente puede hacer una diferencia.

Por eso digo que "la vida es corta". No es que sea corta, es que es demasiado
corta para perder tiempo haciendo lo que ya está hecho o buscándole la quinta
pata al gato. Hay que sobreponerse a la tristeza de que nunca vamos a usar 100%
programas hechos por nosotros y nuestros amigos, y aplicar la fuerza en los
puntos críticos, crear las cosas que no existen, no las que ya están.

Antes de decidirse a empezar un proyecto hay que preguntarse muchas cosas:

* ¿Me va a dejar plata?

* ¿Qué es lo nuevo de este proyecto?

* ¿Tengo alguna idea de implementación que nadie tuvo?

* ¿Tengo alguna idea de interface original?

* ¿Por qué alguien va a querer usar eso?

* ¿Tengo tiempo y ganas de encarar este proyecto?

* ¿Me voy a divertir haciéndolo?

Las más importantes son probablemente la última y la primera. La primera porque
de algo hay que vivir, y la última porque es suficiente. Si uno decide que sí,
que va a encarar un proyecto, hay que tratar de programar lo menos posible.

Una de las tentaciones del programador es afeitar yaks [#]_: es una
actividad inútil en sí misma, que uno espera le dé beneficios más adelante.

.. [#] Frase inventada por `Carlin Vieri <http://projects.csail.mit.edu/gsb/old-archive/gsb-archive/gsb2000-02-11.html>`_

       Yo estoy escribiendo este libro que tiene links a URLs. Yo quiero que
       esas URLs sean válidas para siempre. Entonces necesito poder editarlas
       **después** de que se imprima el libro y me gustaría un "acortador" de
       URLs donde se puedan editar. Como no lo encuentro lo escribo.

       Si siguiera con "y para eso necesito hacer un framework web, y un
       módulo para almacenar los datos"... estoy afeitando yaks.

Para poder hacer A, uno descubre que necesita B, para B necesita C.
Cuando llegás a D... estás afeitando yaks.

Si necesitás B para lograr A, entonces, buscá una B en algún lado, y **usala**.
Si realmente no existe nada parecido, entonces ahora tenés dos proyectos. Pensá
si te interesa más A o B, y si podés llevar los dos adelante. Es un problema.

En este capítulo lo que vamos a hacer es aprender a no reinventar la rueda.
Vamos a elegir un objetivo y vamos a lograrlo sin afeitar ningún yak. Vas
a ver como creamos un programa útil con casi nada de código propio.

El Problema
~~~~~~~~~~~

Lo describe Tarek Ziadé en `URLs in Books <http://tarekziade.wordpress.com/2009/04/19/urls-in-books/>`_:

    Recibí algunas quejas acerca de que algunos links en mis libros no
    funcionaban cuando fueron publicados.

    Para el próximo libro que estoy escribiendo, le propuse a mi editor crear un
    sitio para registrar las referencias mencionadas.

    Usando referencias ascii cortas y únicas a lo largo del libro, es facil
    proveer un servicio sencillo de redirección a la URL de destino, y
    arreglarlo cuando cambie (simplemente creando un alerta de email si la
    redirección da error 404).

Ya que no tengo editor, lo voy a tener que hacer yo mismo. Me parece una buena
idea, va a ser útil para este proyecto, no encuentro nada hecho similar, es un
buen ejemplo del objetivo de este capítulo... ¡vendido!

Una vez decidido a encarar este proyecto, establezcamos las metas:

* Un redirector estilo tinyURL, bit.ly, etc.

* Que use URLs cortas y memotécnicas.

* Que el usuario pueda editar las redirecciones en cualquier momento.

* Que notifique cuando la URL no sirva, para poder corregirla.

Además, como metas "ideológicas":

* Un mínimo de afeitado de yaks.

* Que sea un programa relativamente breve.

* Código lo más simple posible: no hay que hacerse el piola, porque no quiero
  mantener algo complejo.

* Cada vez que haya que hacer algo: buscar si ya está hecho (excepto el programa
  en sí, sino el capítulo termina dentro de dos renglones).

Separemos la tarea en componentes:

* Una función que dada una URL genera un slug [#]_
* Un componente para almacenar las relaciones slug => URL
* Un sitio web que haga la redirección
* Un mecanismo de edición de las relaciones

.. [#] Slug es un término que ví en Django: un identificador único formado
       con letras y números. En este caso, es la parte única de la URL.

Veamos los componentes elegidos para este desarrollo.

Bottle
~~~~~~

Esto va a ser una aplicación web. Hay docenas de frameworks para crearlas
usando Python. Voy a elegir casi al azar uno que se llama
`Bottle <http://bottle.paws.de>`_ porque es sencillo, sirve para lo que
necesitamos, y es un único archivo. Literalmente se puede aprender a usar
en una hora.

¿Qué Páginas tiene nuestra aplicación web?

* ``/`` donde el usuario se puede autenticar o ver un listado de sus
  redirecciones existentes.

* ``/SLUG/edit/`` donde se edita una redirección (solo para el dueño del slug).

* ``/SLUG/del/`` para eliminar una redirección (solo para el dueño del slug).

* ``/SLUG`` redirige al sitio deseado.

* ``/static/archivo`` devuelve un archivo (para CSS, imágenes, etc)

* ``/logout`` cierra la sesión del usuario.


Empecemos con un "stub", una aplicación bottle mínima que controle esas URLs.
El concepto básico en bottle es:

* Creás una función que toma argumentos y devuelve una página web
* Usás el decorador ``@bottle.route`` para que un PATH de URL determinado
  llame a esa función.
* Si querés que una parte de la URL sea un argumento de la función, usás
  ``:nombrearg`` y la tomás como argumento (ej: ver en el listado, función
  borrar)

Después hay más cosas, pero esto es suficiente por ahora:

.. class:: titulo-listado

pyurl1.py

.. class:: listado

.. code-block:: python
   :linenos:
   :include: codigo/2/pyurl1.py


Para probarlo, alcanza con ``python pyurl1.py`` y sale esto en la consola::

    $ python pyurl1.py
    Bottle server starting up (using WSGIRefServer())...
    Listening on http://127.0.0.1:8080/
    Use Ctrl-C to quit.

Apuntando un navegador a esa URL podemos verificar que cada función responde en
la URL correcta y hace lo que tiene que hacer:

.. figure:: pyurl1-1.print.png

   La aplicación de prueba funcionando.

Autenticación
~~~~~~~~~~~~~

Bottle es un framework `WSGI <http://wsgi.org/>`_. WSGI es un standard para crear
aplicaciones web. Permite conectarlas entre sí, y hacer muchas cosas interesantes.

En particular, tiene el concepto de "middleware". ¿Qué es el middleware? Es una
aplicación intermediaria. El pedido del cliente va al middleware, este lo
procesa y luego se lo pasa a tu aplicación original.

En nuestro caso, queremos que ciertas partes de la aplicación estén autenticadas.
Bueno, la manera práctica es usar un middleware de autenticación que se encargue
de todo y a nosotros simplemente nos interesa saber qué usuario es.

Vamos a usar `AuthKit <http://authkit.org/>`_ con OpenID. De esa manera vamos
a evitar una de las cosas más molestas de las aplicaciones web, la proliferación
de cuentas de usuario.

Al usar OpenID, no vamos a tener ningún concepto de usuario propio, simplemente
vamos a confiar en que OpenID haga su trabajo y nos diga "este acceso lo está
haciendo el usuario X".

¿Cómo se autentica el usuario?

* Si tiene una cuenta de Yahoo: ingresa ``yahoo.com``
* Si tiene una cuenta de Google: ingresa
  ``https://www.google.com/accounts/o8/id`` [#]_

.. [#] O se crean botones "Entrar con tu cuenta de google", etc.

Luego OpenID se encarga de autenticarlo via Yahoo/Google/etc. y darnos el
usuario autenticado como parte de la sesión.

Hagamos entonces que nuestra aplicación de prueba soporte OpenID.

Necesitamos importar varios módulos nuevos [#]_:

.. [#] Hasta donde sé, necesitamos instalar:

       * AuthKit
       * Beaker
       * PasteDeploy
       * PasteScript
       * WebOb
       * Decorator

.. class:: titulo-listado

pyurl1.py

.. class:: listado

.. code-block:: python
   :linenos:
   :linenos_offset:
   :include: codigo/2/pyurl2.py
   :start-at: # Middlewares
   :end-before: @bottle.route

Si queremos que una función sólo esté disponible para usuarios autenticados,
lo verificamos. De no ser así, se da un error 401. El middleware intercepta
esos errores y muestra la pantalla de login.

.. class:: titulo-listado

pyurl1.py

.. class:: listado

.. code-block:: python
   :linenos:
   :linenos_offset:
   :include: codigo/2/pyurl2.py
   :start-at: @bottle.route('/')
   :end-before: @bottle.route('/:slug/edit')
    

Implementamos logout:

.. class:: titulo-listado

pyurl1.py

.. class:: listado

.. code-block:: python
   :linenos:
   :linenos_offset:
   :include: codigo/2/pyurl2.py
   :start-at: @bottle.route('/logout')
   :end-before: @bottle.route('/')

Por último, se "envuelve" la aplicación con el middleware de autenticación:

.. class:: titulo-listado

pyurl1.py

.. class:: listado

.. code-block:: python
   :linenos:
   :linenos_offset:
   :include: codigo/2/pyurl2.py
   :start-at: if __name__=='__main__':

¿Funciona?

.. figure:: pyurl2-1.print.png

   El sitio muestra una pantalla de login (Es fea porque es la que
   viene por default)

.. figure:: pyurl2-2.print.png

   Tal vez, el proveedor de OpenID pide usuario/password

.. figure:: pyurl2-3.print.png

   Por una única vez se pide autorizar al otro sitio. 

.. figure:: pyurl2-4.print.png

   Estamos autenticados y nuestra aplicación de prueba funciona como antes.

Storm
~~~~~

Es obviamente necesario guardar las relaciones usuario/slug/URL en alguna parte.
Lo obvio es usar una base de datos. Lo inteligente es usar un ORM.

A favor de usar un ORM:
    No se usa SQL directo, lo que permite hacer todo (o casi) en Python. El
    programa queda más "limpio" al no tener que cambiar de contexto todo el
    tiempo.

En contra de usar un ORM:
    Es una dependencia extra, te ata a un producto que tal vez mañana
    "desaparezca". Puede tener una pérdida de performance con respecto a usar
    la base de datos en forma directa.

No me parece grave: Si tenemos cuidado y aislamos el ORM del resto de la
aplicación, es posible reemplazarlo con otro más adelante (o eliminarlo
y "bajar" a SQL o a NoSQL).

Por lo tanto, en el espíritu de "no inventes, usá", vamos a usar un ORM. En
particular vamos a usar `Storm <https://storm.canonical.com/>`_, un ORM
creado por Canonical, que me gusta [#]_.

.. [#] Me gusta más `Elixir <http://elixir.ematia.de/trac/wiki>`_ pero es
       bastante más complicado para algunas cosas.

HTML
~~~~

Soy un cero a la izquierda en cuanto a diseño gráfico, HTML, estética, etc. En
consecuencia, para CSS y demás simplemente busqué algo fácil de usar y lo usé.
Todo el "look" del sitio va a estar basado en `BlueTrip <http://bluetrip.org/>`_
un framework de CSS:

    BlueTrip te da un conjunto razonable de estilos y una forma común de
    construir un sitio web para que puedas saltear la parte aburrida y
    ponerte a diseñar.

Dado que no pienso diseñar mucho, ¡gracias BluTrip!

