Diseño de Interfaz Gráfica
--------------------------

    "¿Cómo se hace una estatua de un elefante? Empezás con un bloque
    de mármol y sacás todo lo que no parece un elefante."

    -- Anónimo.

    "Abandonen la esperanza del valor añadido a través de la rareza.
    Es mejor usar técnicas de interacción consistentes que le den a
    los usuarios el poder de enfocarse en tu contenido, en vez de
    preguntarse como se llega a él."

    -- Jakob Nielsen

¿Siendo un programador, qué sabe uno de diseños de interfaces? La respuesta,
al menos en mi caso es poco y nada. Sin embargo, hay unos cuantos principios
que ayudan a que uno no cree interfaces *demasiado* horribles, o a
veces hasta agradables.

* Aprender de otros.

  Estamos rodeados de ejemplos de buenas y malas interfaces. Copiar es bueno.

* Contenerse.

  Tenemos una tendencia natural a crear cabinas de Concord. No te digo que no
  está buena la cabina de un Concord, lo que te digo es que para hacer tostadas
  es demasiado.


  .. figure:: concord.jpg
     :width: 80%

     Concord cockpit by wynner3, licencia CC-BY-NC (http://www.flickr.com/photos/wynner3/3805698150/)

  En general, dado que uno no tiene la habilidad (en principio) de crear
  asombrosas interfaces, lo mejor es crear lo menos posible. ¡Lo que no está
  ahí no puede estar *tan* mal!

* Pensar mucho *antes*.

  Siempre es más fácil agregar y mantener un feature bien pensado, con una
  interfaz limitada, que tratar de hacer que funcione una pila de cosas a medio
  definir.

  Si no sabés *exactamente* cómo funciona tu aplicación, no estás listo para
  hacer una interfaz usable para ella. Sí podés hacer una de prueba.

* Tirá una.

  Hacé una interfaz mientras estás empezando. Después tirála. Si hiciste una
  clara separación de capas eso debería ser posible.

* Pedí ayuda.

  Si tenés la posibilidad de que te de una mano un experto en usabilidad, usála.
  Sí, ya sé que vos podés crear una interfaz que funcione, eso es lo *fácil*, lo
  difícil es crear una interfaz que alguien quiera usar.

Más allá de esos criterios, en este capítulo vamos a tomar la interfaz creada en el
capítulo anterior y la vamos a rehacer, pero bien. Porque esa era la de
desarrollo, y la vamos a tirar.

Proyecto
--------

Asumamos que la aplicación de streaming de radio que desarrollamos en el
capítulo anterior funciona correctamente y carece de bugs [#]_...
¿Qué hay que hacer ahora?

.. [#] No es así, pero estoy escuchando música con ella ¡En este mismo
       momento!

Bueno, falta resolver todas las cosas que **no** son bugs desde el punto de
vista de funcionamiento pero que están mal.

Corrigiendo la Interfaz Gráfica
-------------------------------

Empecemos con la ventana de configuración, viendo algunos problemas
de base en el diseño. Desde ya que el 90% de lo que veamos ahora es
discutible. Es más, como no soy un experto en el tema, es probable
que el 90% esté **equivocado**. Sin embargo, hasta que consiga un
experto en UI que le pegue una revisada... es lo que hay [#]_.

.. [#] De hecho, pedí ayuda en twitter/identi.ca y `mi blog <http://lateral.netmanagers.com.ar/weblog/posts/BB889.html>`_ y salieron
       unas cuantas respuestas, incluyendo un `post en
       otro blog <http://thesmithfam.org/blog/2010/05/16/whats-wrong-with-this-dialog/>`_.
       ¡Con mockups y todo!

.. figure:: radio-14.print.jpg
   :width: 40%

   Funciona, pero tiene problemas.

Esa ventana tiene *muchos* problemas.

.. figure:: radio-15.print.jpg
   :width: 40%

   Botón "Close" no alineado.

Normalmente no vas a ver este caso cubierto en las guías de diseño de
interfaz porque estamos usando un layout "columna de botones" que no
es de lo más standard.

Si hubiera más de un botón abajo, entonces tal vez "Close" se vería
como perteneciente a ese elemento visual, sin embargo, al estar solo,
se lo ve como un elemento de la columna, aunque "destacado" por la
separación vertical.

Al ser "absorbido" visualmente por esa columna, queda muy raro que
no tenga el mismo ancho que los otros botones.

Como no debemos asignar anchos fijos a los botones (por motivos que
vamos a ver más adelante) debemos solucionarlo usando layout
managers.

Una manera de resolverlo es una matriz 2x2 con un grid layout:

.. figure:: radio-18.print.jpg
   :width: 40%

   Botón "Close" alineado.

El resultado final es bastante más armónico, y divide visualmente
el diálogo en dos componentes claros, la lista a la izquierda, los
controles a la derecha.

Lo que nos lleva al segundo problema:

.. figure:: radio-17.print.jpg
   :width: 40%

   Espacio muerto.

Si el layout es "dos columnas" entonces no tiene sentido que la lista
termine antes del fondo del diálogo. Nuevamente, si hubiera dos
botones abajo (por ejemplo, "Accept" y "Reject"), entonces sí tendría
sentido extender ese componente visual hacia la izquierda.

Al tener sólo uno, ese espacio vacío es innecesario y antifuncional.

Entonces cambiamos el esquema de layouts, y terminamos con un layout
horizontal de dos elementos, el derecho un layout vertical conteniendo
todos los botones:

.. figure:: radio-19.print.jpg
   :width: 40%

   Resultado con layout horizontal.

El siguiente problema es que al tener iconos y texto, y al estar
centrado el contenido de los botones, se ve horrible:

.. figure:: radio-16.print.jpg
   :width: 40%

   Etiquetas centradas con iconos a la izquierda.

Hay varias soluciones para esto:

* Podemos no poner iconos: El texto centrado no molesta tanto
  visualmente.

* Podemos no centrar el contenido de los botones: Se ve mejor,
  pero es muy poco standard [#]_

.. [#] Ver la cita de Nielsen al principio del capítulo.

* Podemos no poner texto en el botón sino en un tooltip: Funciona,
  es standard, resuelve el alineamiento, hace la interfaz levemente
  menos obvia.

* Mover algunos elementos inline en cada item (los que afectan a un
  único item) y mover los demás a una línea horizontal por debajo de
  la lista.

O ... podemos dejar de ponerle lapiz de labios al chancho y admitir
que es un chancho.

El problema de este diálogo no es que los botones estén desalineados,
es que no sabemos siquiera porqué los botones están.

Así que, teniendo una interfaz que funciona, hagamos un desarrollo
racional de la versión nueva, y olvidemos la vieja.

¿Qué estamos haciendo?
----------------------

Pensemos el objetivo, la tarea a realizar. Es controlar una lista de
radios. Lo mínimo sería esto:

* Agregar radios nuevas (Add).
* Cambiar algo en una radio ya existente (Edit).
* Sacar radios que no nos gustan  más (Delete).
* Cerrar el diálogo (Close) [#]_

.. [#] Podríamos tener "Apply", "Cancel", etc, pero me gusta más
       la idea de este diálogo como de aplicación instantánea,
       "aplicar cambios" es un concepto nerd. La manipulación
       directa es la metáfora moderna. Bah, es una opinión.

Adicionalmente teníamos esto:

* Cambiar el orden de las radios en la lista

¿Pero... porqué estaba? En nuestro caso es porque nos robamos la
interfaz de RadioTray, pero... ¿alguien necesita hacerlo? ¿Porqué?

Veamos las justificaciones que se me ocurren:

1) Poner las radios más usadas al principio.

   Pero... ¿No sería mejor si el programa mostrara las últimas radios
   usadas al principio en forma automática?
   
2) Organizarlas por tipo de radio (ejemplo: tener todas las de
   música country juntas)

   Para hacer esto correctamente, creo que sería mejor tener múltiples
   niveles de menúes. También podríamos agregarle a cada radio un
   campo "género" o tags, y usar eso para clasificarlas.

En ambos casos, me parece que el ordenamiento manual no es la manera
correcta de resolver el problema. Es casi lo contrario de un feature.
Es un anti-feature que sólo sirve para que a los que realmente querrían
un feature determinado se les pueda decir "usá los botones de ordenar".

Si existe algún modelo de uso para el que mover las radios usando
flechitas es el modo de interacción correcta... no se me ocurre y
perdón desde ya.

Por lo tanto, este "feature" va a desaparecer por ahora.

Si no tenemos los botones de subir y bajar, no tiene tanto sentido
la idea de una columna de botones a la derecha, y podemos pasar
a un layout con botones horizontales:

.. figure:: radio-20.print.jpg
   :width: 54%

   Repensando el diálogo. Ya que estamos "Done" es más adecuado para
   el botón que "Close".

¿En qué se parecen y en qué se diferencian esos cuatro botones que
tenemos ahí abajo?

* Edit y Remove afectan a una radio que esté seleccionada.
* Add y Done no dependen de la selección en la lista.

¿Que pasaría si pusiéramos Edit y Remove en los items mismos? Bueno,
lo primero que pasaría es que tendríamos que cambiar código porque
el QListWidget soporta una sola columna y tenemos que pasar a un
QTreeWidget. Veamos como funciona en la GUI:

.. figure:: radio-21.print.jpg
   :width: 54%

   ¡Less is more!

También al no tener más botones de Edit y Remove, hay que mover un
poco el código porque ahora responde a otras señales.

La parte interesante (no mucho) del código es esta:

.. class:: titulo-listado

radio6.py

.. class:: listado

.. code-block:: python
   :linenos:
   :linenos_offset:
   :include: codigo/6/radio6.py
   :start-after: # XXX1
   :end-before: # XXX2

¿Es esto todo lo que está mal? Vaya que no.

Pulido
------

Los iconos que venimos usando son del set "Reinhardt" que a mí
personalmente me gusta mucho, pero algunos de sus iconos no son
exactamente obvios. ¿Por ejemplo, esto te dice "Agregar"?

.. figure:: filenew.pdf
   :width: 25%

Bueno, en cierta forma sí, pero está pensado para documentos. Sería
mejor por ejemplo un signo +. De la misma forma, si bien la X funciona
como "remove", si usamos un + para "Add", es mejor un - para "Remove".

Y para "Edit" es mejor usar un lápiz y no un destornillador. El
problema ahí es usar el mismo icono que para "Configure". Si bien
ambos casos son acciones relacionadas, son lo suficientemente
distintas para merecer su propio icono.

.. figure:: radio-22.print.jpg
   :width: 54%

   ¡Shiny!
